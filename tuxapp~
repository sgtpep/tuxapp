#!/bin/bash
# shellcheck disable=SC2034
set -eu -o pipefail

declare -Ar desktop_entry_categories=(
  [audio]="AudioVideo;Audio;"
  [development]="Development;"
  [education]="Education;"
  [games]="Game;"
  [graphics]="Graphics;"
  [network]="Network;"
  [office]="Office;"
  [science]="Science;"
  [system]="System;"
  [utilities]="Utility;"
  [video]="AudioVideo;Video;"
)

function check_nested_file_list {
  declare -n argument_file_list_arguments=$1
  declare -n result_is_file_list_nested=$2

  result_is_file_list_nested=1
  declare directory_name
  while read -r; do
    [[ ${directory_name-} ]] || declare -r directory_name=${REPLY%%/*}
    [[ $REPLY != $directory_name/* ]] || continue

    result_is_file_list_nested=
    break
  done < <("${argument_file_list_arguments[@]}")
  readonly result_is_file_list_nested
}

function create_app_desktop_entry {
  declare -r app_id=$1
  declare -n argument_appfile=$2

  declare -r desktop_entry_path=$data_path/applications/tuxapp-$app_id.desktop

  if [[ -f $desktop_entry_path ]]; then
    declare -r is_desktop_entry_existing=1
  else
    declare -r is_desktop_entry_existing=
  fi

  declare -r app_name=${argument_appfile[name]-$app_id}

  declare -r desktop_entry_category=${desktop_entry_categories[${argument_appfile[category]-}]-}
  declare -r icon_path=$data_path/icons/tuxapp-$app_id
  declare -r run_path=$base_path/$app_id/run
  write_file "$desktop_entry_path" << EOF
[Desktop Entry]
Categories=$desktop_entry_category
Comment=${argument_appfile[title]-}
Exec=$run_path %U
Icon=$icon_path
Name=$app_name
TryExec=$run_path
Type=Application
EOF

  [[ $is_desktop_entry_existing ]] || echo "Added the menu item '$app_name'" >&2
}

function create_app_icon {
  declare -r app_id=$1
  declare -r is_app_updated=$2
  declare -r appfile_icon_url=$3

  [[ $appfile_icon_url ]] || return 0

  declare -r icon_path=$data_path/icons/tuxapp-$app_id
  if [[ ! -f $icon_path || $is_app_updated ]]; then
    download_file "$appfile_icon_url" "$icon_path" || :
  fi
}

function create_app_run_script {
  declare -r app_id=$1
  declare -r appfile_executable_arguments=$2
  declare -r appfile_firejail_options=$3

  if [[ $appfile_executable_arguments ]]; then
    declare -r executable_arguments=($appfile_executable_arguments)
  else
    declare executable_arguments
    detect_app_executable "$app_id" executable_arguments
  fi

  declare -r run_path=$base_path/$app_id/run

  if [[ ! -v TUXAPP_FIREJAIL && -f $run_path ]]; then
    output=$(< "$run_path")
    declare -r run_contents=$output

    declare is_firejail_enabled=${run_contents##*is_firejail_enabled=}
    is_firejail_enabled=${is_firejail_enabled%%$'\n'*}

    declare quoted_firejail_options=${run_contents##*user_firejail_options=}
    quoted_firejail_options=${quoted_firejail_options%%$'\n'*}
    readonly quoted_firejail_options

    eval declare firejail_options="$quoted_firejail_options"
  else
    declare is_firejail_enabled=1
    declare firejail_options=
  fi

  write_file "$run_path" << EOF
#!/bin/bash
app_firejail_options=${appfile_firejail_options@Q}
executable_arguments=(${executable_arguments[@]@Q})
is_firejail_enabled=$is_firejail_enabled
user_firejail_options=${firejail_options@Q}

. "\${0%/*/*}"/common/run.sh
EOF
  chmod +x "$run_path"
}

function create_common_run_script {
# shellcheck disable=SC2034
}

function detect_app_executable {
  declare -r app_id=$1
  declare -n result_executable_arguments=$2

  declare -r dist_path=$base_path/$app_id/dist

  if [[ -x $dist_path/AppRun ]]; then
    result_executable_arguments=(AppRun)
  elif [[ -d $dist_path/usr/bin ]]; then
    result_executable_arguments=()
    declare -r bin_paths=("$dist_path"/usr/bin/*)
    if [[ ${#bin_paths[@]} == 1 && -x ${bin_paths[0]} ]]; then
      declare -r executable_argument="${bin_paths[0]#$dist_path/}"
      result_executable_arguments=("$executable_argument")
    fi
  else
    result_executable_arguments=()
    declare test_path
    for test_path in "$dist_path"/*; do
      declare test_filename=${test_path##*/}
      declare lowercase_test_filename=${test_filename,,}
      [[ $lowercase_test_filename == "$app_id" && -x $test_path ]] || continue

      result_executable_arguments=("$test_filename")
      break
    done
  fi
  readonly result_executable_arguments

  [[ ${result_executable_arguments-} ]] || raise_error "Unable to determine the executable file"
}

function extract_app_download {
  declare -r download_path=$1
  declare -r extract_path=$2

  output=$(head -c 3 "$download_path")
  declare -r download_signature=$output

  if [[ $download_signature == ?EL ]]; then
    extract_appimage_download "$download_path" "$extract_path"
  elif [[ $download_signature == !\<a ]]; then
    extract_debian_package "$download_path" "$extract_path" --checkpoint=.250
  elif [[ $download_signature == PK? ]]; then
    extract_zip_download "$download_path" "$extract_path"
  else
    extract_tarball_download "$download_path" "$extract_path"
  fi
}

function extract_appimage_download {
  declare -r download_path=$1
  declare -r extract_path=$2

  declare -r root_path=$base_path/common/root

  declare -r bsdtar_path=$root_path/usr/bin/bsdtar
  declare -r ld_library_path=$root_path/usr/lib/x86_64-linux-gnu
  if LD_LIBRARY_PATH=$ld_library_path "$bsdtar_path" -t -f "$download_path" &> /dev/null; then
    make_directory "$dist_path"
    LD_LIBRARY_PATH=$ld_library_path "$bsdtar_path" -x -C "$dist_path" -f "$download_path"
  else
    chmod +x "$download_path"

    declare command_arguments=()
    ! type firejail &> /dev/null || command_arguments+=(firejail)
    command_arguments+=("$download_path" --appimage-extract)
    readonly command_arguments

    declare -r parent_path=${extract_path%/*}

    make_directory "$parent_path"
    cd "$parent_path" || raise_error "Unable to change the directory"
    "${command_arguments[@]}"
    cd - > /dev/null

    rename_directory "$parent_path"/squashfs-root "$extract_path"
  fi
}

function extract_tarball_download {
  declare -r download_path=$1
  declare -r extract_path=$2

  declare -r file_list_arguments=(tar -t -f "$download_path")
  declare is_file_list_nested
  check_nested_file_list file_list_arguments is_file_list_nested

  extract_tarball "$download_path" "$extract_path" --checkpoint=.250 ${is_file_list_nested:+--strip-components=1}
}

function extract_zip_download {
  declare -r download_path=$1
  declare -r extract_path=$2

  make_directory "$dist_path"
  unzip -o -d "$extract_path" "$download_path"

  declare -r file_list_arguments=(zipinfo -1 "$download_path")
  declare is_file_list_nested
  check_nested_file_list file_list_arguments is_file_list_nested

  [[ ! $is_file_list_nested ]] || rename_directory "$extract_path"/* "$extract_path"
}

function get_app_download_urls {
  declare -r app_id=$1
  declare -n argument_appfile=$2
  declare -r app_version=$3
  declare -n result_download_urls=$4

  declare -A architecture
  detect_architecture architecture

  result_download_urls=()
  declare key
  for key in download-{tarball,appimage,deb}-${architecture[tuxapp]}-url; do
    [[ ${argument_appfile[$key]-} ]] || continue

    result_download_urls=(${argument_appfile[$key]})
    break
  done

  [[ ${result_download_urls-} ]] || raise_error "No suitable release download URL for $app_id"

  result_download_urls=("${result_download_urls[@]//{version\}/$app_version}")
  readonly result_download_urls
}

function get_excluded_package_names {
  declare -n result_excluded_package_names=$1

  output=$(< "$cache_path"/common-packages)
  declare -r common_package_url_paths=($output)

  declare excluded_common_package_names=("${common_package_url_paths[@]##*/}")
  excluded_common_package_names=("${excluded_common_package_names[@]%%_*}")
  readonly excluded_common_package_names

  result_excluded_package_names=("${ignored_package_names[@]}" "${excluded_common_package_names[@]}")
  readonly result_excluded_package_names
}

function install_app {
  declare installed_app_version
  declare released_app_version
  read_app_versions "$app_id" appfile installed_app_version released_app_version

  declare -r app_path=$base_path/$app_id

  if [[ -d $app_path ]]; then
    declare -r is_app_existing=1
  else
    declare -r is_app_existing=
  fi

  if [[ $installed_app_version != "$released_app_version" ]]; then
    declare download_urls
    get_app_download_urls "$app_id" appfile "$released_app_version" download_urls

    declare download_url
    for download_url in "${download_urls[@]}"; do
      declare download_path=$cache_path/$app_id-$released_app_version

      download_file "$download_url" "$download_path"

      echo "Unpacking $app_id $released_app_version" >&2
      extract_app_download "$download_path" "$app_path"/dist
    done

    write_file "$app_path"/version "$released_app_version"
  fi

  if [[ ${appfile[tuxapp-packages]-} ]]; then
    declare excluded_common_package_names
    get_excluded_package_names excluded_package_names

    declare -r package_names=(${appfile[tuxapp-packages]})
    declare package_url_paths
    resolve_package_url_paths package_names excluded_package_names package_url_paths

    install_packages "$app_id" "${package_url_paths[@]}"
  fi

  if [[ $installed_app_version == "$released_app_version" ]]; then
    declare -r is_app_updated=
  else
    declare -r is_app_updated=1
  fi

  create_app_icon "$app_id" "$is_app_updated" "${appfile[icon-url]-}"
  create_app_run_script "$app_id" "${appfile[tuxapp-executable]-}" "${appfile[tuxapp-firejail]-}"
  create_app_desktop_entry "$app_id" appfile

  if [[ $is_app_updated ]]; then
    if [[ $is_app_existing ]]; then
      echo "Updated $app_id to $released_app_version" >&2
    else
      echo "Installed $app_id $released_app_version" >&2
    fi
  else
    echo "$app_id $installed_app_version is up to date" >&2
  fi
}

function rename_directory {
  declare -r source_path=$1
  declare -r destination_path=$2

  make_directory "$destination_path"
# TODO: mv?
  cp -r "$source_path"/* "$destination_path"
  ! ls "$source_path"/.[!.]* &> /dev/null || cp -r "$source_path"/.[!.]* "$destination_path"

  rm -r "$source_path"
}
