#!/usr/bin/env python
from __future__ import print_function
import functools
import imp
import os
import re
import sys

try:
  from html.parser import HTMLParser
except ImportError:
  from HTMLParser import HTMLParser

tuxapp = imp.load_source('tuxapp', os.path.join(os.path.dirname(__file__), 'tuxapp'))
validate = imp.load_source('validate', os.path.join(os.path.dirname(__file__), 'validate'))

def validates(validate_function):
  def decorator(function):
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
      result = None
      while True:
        try:
          if result is not None:
            validates.prefill = result
          result = function(*args, **kwargs)
          if hasattr(validates, 'prefill'):
            del validates.prefill
          validate_function(*args, result=result, **kwargs)
          return result
        except AssertionError as exception:
          print(exception.args[0] if exception.args else "Unknown error", file=sys.stderr)
    return wrapper
  return decorator

class BaseParser(HTMLParser):
  contents = ''
  contents_attributes = {}
  contents_tag = None
  is_head = False
  previous_attributes = {}
  previous_tag = None

  data_types = (
    'Product',
    'SoftwareApplication',
    'WebSite',
  )

  def __init__(self, *args, **kwargs):
    HTMLParser.__init__(self, *args, **kwargs)
    self.results = []

  def add_result(self, result):
    self.results.append(result)

  def feed(self, *args, **kwargs):
    HTMLParser.feed(self, *args, **kwargs)
    self.raise_result()

  def handle_data(self, data):
    getattr(self, 'on_data', lambda *args, **kwargs: None)(self.previous_tag, self.previous_attributes, data)
    if self.contents_tag:
      self.contents += data
    if self.previous_attributes.get('itemprop'):
      type = self.previous_attributes['itemtype'].rsplit('/', 1)[-1] if 'itemtype' in self.previous_attributes else None
      getattr(self, 'on_schema_org', lambda *args, **kwargs: None)(type, self.previous_attributes['itemprop'], data)
    if self.previous_tag == 'script' and self.previous_attributes.get('type') == 'application/ld+json' and data.strip():
      import json
      decoded_data = json.loads(data)
      items = decoded_data if isinstance(decoded_data, list) else [decoded_data]
      for item in items:
        if item.get('@type') in self.data_types:
          getattr(self, 'on_json_ld', lambda *args, **kwargs: None)(item)

  def handle_endtag(self, tag):
    if tag == self.contents_tag:
      getattr(self, 'on_contents', lambda *args, **kwargs: None)(self.contents_tag, self.contents_attributes, self.contents)
      self.contents = ''
      self.contents_attributes = {}
      self.contents_tag = None
    if self.is_head and tag == 'head':
      self.raise_result()

  def handle_starttag(self, tag, attributes):
    attributes = dict(attributes)
    getattr(self, 'on_tag', lambda *args, **kwargs: None)(tag, attributes)
    if tag == 'meta' and attributes.get('content') and attributes.get('itemprop'):
      type = self.previous_attributes['itemtype'].rsplit('/', 1)[-1] if 'itemtype' in self.previous_attributes else None
      getattr(self, 'on_schema_org', lambda *args, **kwargs: None)(type, attributes['itemprop'], attributes['content'])
    self.previous_attributes = attributes
    self.previous_tag = tag

  def raise_result(self):
    if self.results:
      raise ResultException(sorted(self.results)[-1][-1])

  def read_contents(self, tag, attributes):
    self.contents_attributes = attributes
    self.contents_tag = tag

class BaseURLParser(BaseParser):
  def on_tag(self, tag, attributes):
    if tag == 'base' and attributes.get('href'):
      raise ResultException(attributes['href'])

class DescriptionParser(BaseParser):
  priority = (
    'description',
    'og-description',
    'schema-org-WebSite',
    'json-ld-WebSite',
    'schema-org-Product',
    'json-ld-Product',
    'schema-org-SoftwareApplication',
    'json-ld-SoftwareApplication',
  )

  def on_json_ld(self, item):
    if item.get('description'):
      self.add_result((self.priority.index('json-ld-{}'.format(item['@type'])), item['description']))

  def on_schema_org(self, type, property, content):
    if type in self.data_types and property == 'description':
      self.add_result((self.priority.index('schema-org-{}'.format(type)), content))

  def on_tag(self, tag, attributes):
    if tag == 'meta' and attributes.get('content'):
      if attributes.get('name') == 'description':
        self.add_result((self.priority.index('description'), attributes['content']))
      elif attributes.get('property') == 'og:description':
        self.add_result((self.priority.index('og-description'), attributes['content']))

class IconURLParser(BaseParser):
  is_head = True

  rels = (
    "shortcut icon",
    'apple-touch-icon',
    'apple-touch-icon-precomposed',
    'icon',
  )

  def on_tag(self, tag, attributes):
    if tag == 'link' and attributes.get('href') and attributes.get('rel') in self.rels:
      self.add_result((
        int(attributes.get('sizes', "0x0").split('x', 1)[0]),
        self.rels.index(attributes['rel']),
        attributes['href'],
      ))

class NameParser(BaseParser):
  priority = (
    'heading-anchor',
    'og-site-name',
    'schema-org-WebSite',
    'json-ld-WebSite',
    'schema-org-Product',
    'json-ld-Product',
    'schema-org-SoftwareApplication',
    'json-ld-SoftwareApplication',
    'application-name',
  )

  def on_contents(self, tag, attributes, contents):
    if tag in ('a', 'h1'):
      self.add_result((self.priority.index('heading-anchor'), contents))

  def on_json_ld(self, item):
    if item.get('name'):
      self.add_result((self.priority.index('json-ld-{}'.format(item['@type'])), item['name']))

  def on_schema_org(self, type, property, content):
    if type in self.data_types and property == 'name':
      self.add_result((self.priority.index('schema-org-{}'.format(type)), content))

  def on_tag(self, tag, attributes):
    if tag == 'a' and self.previous_tag == 'h1' or tag == 'h1' and self.previous_tag == 'a':
      self.read_contents(tag, attributes)
    elif tag == 'meta' and attributes.get('content'):
      if attributes.get('name') == 'application-name':
        self.add_result((self.priority.index('application-name'), attributes['content']))
      elif attributes.get('property') == 'og:site_name':
        self.add_result((self.priority.index('og-site-name'), attributes['content']))

class ResultException(Exception):
  pass

class TitleParser(BaseParser):
  is_head = True

  priority = (
    'title',
    'og-title',
  )

  def on_contents(self, tag, attributes, contents):
    if tag == 'title':
      self.add_result((self.priority.index('title'), contents))

  def on_tag(self, tag, attributes):
    if tag == 'meta' and attributes.get('property') == 'og:title' and attributes.get('content'):
      self.add_result((self.priority.index('og-title'), attributes['content']))
    elif tag == 'title':
      self.read_contents(tag, attributes)

def input_text(prompt, prefill='', choices=(), is_whitespacy=False):
  try:
    import readline
    readline.set_startup_hook(lambda: readline.insert_text(getattr(validates, 'prefill', filter_text(prefill, is_whitespacy)).encode('utf-8')))
    history_path = os.path.expanduser("~/.python_history")
    if hasattr(sys, 'ps1') and os.path.isfile(history_path):
      readline.write_history_file(history_path)
    completer, delimeters = readline.get_completer(), readline.get_completer_delims()
    readline.set_completer(lambda text, state: tuple(choice for choice in choices if choice.startswith(text))[state])
    readline.set_completer_delims('')
    try:
      import builtins
    except ImportError:
      import __builtin__ as builtins
    return filter_text(getattr(builtins, 'raw_input', input)("{}: ".format(prompt)).decode('utf-8'), is_whitespacy)
  finally:
    readline.set_startup_hook()
    if hasattr(sys, 'ps1') and os.path.isfile(history_path):
      readline.clear_history()
      readline.read_history_file(history_path)
    readline.set_completer(completer)
    readline.set_completer_delims(delimeters)

@tuxapp.handles_exceptions
def main(arguments=tuple(sys.argv[1:])):
  appfile = \
    dict(validate.parse_appfile(validate.check_appfile_exists(tuxapp.extract_app(arguments[0]))), app=tuxapp.extract_app(arguments[0])) \
      if arguments else \
    {'app': get_default_app()}
  step = 0
  while True:
    try:
      appfile = get_update_functions()[step](appfile)
      step += 1
      if step == len(get_update_functions()):
        break
    except EOFError:
      raise KeyboardInterrupt
    except KeyboardInterrupt:
      step -= 1
      if step < 0:
        raise KeyboardInterrupt
      if hasattr(validates, 'prefill'):
        del validates.prefill
      print()
  return True

def parse_html(parser, html):
  try:
    parser().feed(html)
    return ''
  except ResultException as exception:
    return filter_text(exception.args[0]) if exception.args and tuxapp.is_string(exception.args[0]) else ''

check_name = lambda url, name: name if validate.check_page_contains(url, name, True) else ''

check_url_protocol = lambda url: url.replace("http://", "https://", 1) if validate.is_url_valid(url) and not validate.check_url_protocol(url) else url

detect_app_executable = lambda app: \
  tuxapp.install_app_distribution(app) and \
  re.sub(r"usr/bin/", '', (tuxapp.unasserts(tuxapp.detect_app_executable)(app) or ''))

detect_version_regex = lambda html: \
  "/download/v([^/]+)" \
    if re.search(r"\bgithub\.com/[\w-]+/[\w-]+/releases/download/\w", html) else \
  '"softwareVersion"\s*:\s*"([^"]+)' \
    if re.search(r'"softwareVersion"\s*:\s*"', html) else \
  '"softwareVersion" content="([^"]+)' \
    if '"softwareVersion" content="' in html else \
  '"softwareVersion">([^<]+)' \
    if '"softwareVersion">' in html else \
  ''

extract_url_name = lambda url: re.sub(r"-+", ' ', re.sub(r"^www\.", '', tuxapp.parse_url(url).netloc).split('.', 1)[0]).title()

fetch_url = tuxapp.memoizes()(
  lambda *args, **kwargs: tuxapp.fetch_url(*args, **kwargs)
)

filter_app = lambda app: re.sub(r"[^a-z0-9]+", '-', app.lower()).strip('-')

filter_description = lambda description: \
  description and u"{}{}{}".format(
    description[0].upper(),
    description[1:],
    '' if description[-1] in validate.get_punctuation() else '.',
  )

filter_download_url = lambda app, urls: filter_download_url_version(app, ' '.join(filter_url(url) for url in urls.split()))

filter_download_url_version = lambda app, url: url and url.replace(tuxapp.fetch_app_version(app), "{version}")

filter_executable = lambda app, command: '' if re.sub(r"usr/bin/", '', command) == detect_app_executable(app) else command

filter_name = lambda name: name.rstrip(''.join(validate.get_punctuation()))

filter_text = lambda string, is_whitespacy=False: \
  string.strip() \
    if is_whitespacy else \
  re.sub(r"\s+", ' ', string.replace('\t', ' ')).strip()

filter_title = lambda title: title and u"{}{}".format(title[0].upper(), title[1:]).rstrip(''.join(validate.get_punctuation()))

filter_url = lambda url: check_url_protocol(filter_url_path(url.split('#', 1)[0]))

filter_url_path = lambda url: "{}/".format(url) if validate.is_url_valid(url) and not tuxapp.parse_url(url).path else url

filter_version_url = lambda homepage_url, url: \
  '' \
    if url == homepage_url else \
  re.sub(r"(\bgithub\.com/[\w-]+/[\w-]+/releases)(?!/latest$).*", r"\1/latest", url)

generate_appfile = lambda appfile: '\n'.join(u"{}={}".format(key, appfile[key]) for key in sorted(appfile) if key != 'app')

get_default_app = lambda: 'temp'

get_update_functions = lambda: \
  (
    update_homepage_url,
    update_name,
    update_app,
    update_category,
    update_group,
    update_free_license,
    update_icon_url,
    update_title,
    update_description,
    update_version_url,
    update_version_regex,
    update_download_x86_64_url,
    update_download_x86_url,
  )

input_app = validates(lambda *args, **kwargs: \
  validate.validate_app(kwargs['result']) and \
  tuxapp.asserts(lambda *args, **kwargs: not input_boolean("Overwrite an existing file?") and "Provide another identifier")(lambda app: not os.path.isfile(tuxapp.get_appfile_path(app)))(kwargs['result'])
)(
  lambda prefill='': filter_app(input_text("Identifier", prefill))
)

input_boolean = lambda question, is_no=False: \
  ('' if re.match(r"^($|n)", input_text("{} [y/N]".format(question)), re.I) else 'yes') \
    if is_no else \
  ('yes' if re.match(r"^($|y)", input_text("{} [Y/n]".format(question)), re.I) else '')

input_category = \
  validates(lambda *args, **kwargs: validate.validate_category(kwargs['result']))(
  tuxapp.logs(lambda *args, **kwargs: "Categories: {}".format(", ".join(validate.get_categories())))(
    lambda prefill='': input_text("Category", prefill, validate.get_categories())
  ))

input_description = validates(lambda app, *args, **kwargs: validate.validate_description(app, kwargs['result']))(
  lambda app, prefill='': filter_description(input_text("Description", prefill))
)

input_download_url = validates(lambda app, architecture, *args, **kwargs: validate.validate_download_url(app, architecture, kwargs['result']))(
  lambda app, architecture, prefill='': filter_download_url(app, input_text("Download URL ({}){}".format(architecture, '' if architecture == 'x86-64' else " (optional)"), prefill))
)

input_executable = validates(
  lambda app, *args, **kwargs: \
    (detect_app_executable(app) or validate.validate_text(kwargs['result'])) and \
    validate.validate_executable(kwargs['result']) and \
    (not kwargs['result'] or tuxapp.resolve_app_executable(app, kwargs['result']))
)(
  lambda app, prefill='': filter_executable(app, input_text("Executable{}".format(" (default: {})".format(detect_app_executable(app)) if detect_app_executable(app) else ''), prefill))
)

input_free_license = validates(lambda *args, **kwargs: validate.validate_free_license(kwargs['result']))(
  lambda prefill='': input_boolean("Is license free?", not prefill)
)

input_group = \
  validates(lambda *args, **kwargs: validate.validate_group(kwargs['result'], True))(
  tuxapp.logs(lambda *args, **kwargs: "Groups: {}".format(", ".join(validate.get_groups())))(
    lambda prefill='': input_text("Group", prefill, validate.get_groups())
  ))

input_homepage_url = validates(lambda *args, **kwargs: validate.validate_homepage_url(kwargs['result']))(
  lambda prefill='': filter_url(input_text("Homepage URL", prefill))
)

input_icon_url = validates(lambda *args, **kwargs: validate.validate_icon_url(kwargs['result']))(
  lambda prefill='': filter_url(input_text("Icon URL", prefill))
)

input_name = validates(lambda app, *args, **kwargs: validate.validate_name(app, kwargs['result']))(
  lambda app, prefill='': filter_name(input_text("Name", prefill))
)

input_title = validates(lambda app, *args, **kwargs: validate.validate_title(app, kwargs['result']))(
  lambda app, prefill='': filter_title(input_text("Title", prefill))
)

input_version_regex = \
  tuxapp.logs_result(lambda app, *args, **kwargs: "Detected version: {}".format(tuxapp.fetch_app_version(app, kwargs['result'])))(
  validates(lambda app, *args, **kwargs: validate.validate_version_regex(app, kwargs['result']))(
    lambda app, prefill='': input_text("Version regex", prefill, (), True)
  ))

input_version_url = validates(lambda *args, **kwargs: validate.validate_version_url(kwargs['result']))(
  lambda homepage_url, prefill='': filter_version_url(homepage_url, filter_url(input_text("Version URL (default: {})".format(homepage_url), prefill)))
)

normalize_url = lambda page_url, url, base_url=None: \
  url \
    if re.match(r"^https?://", url) else \
  "{}:{}".format(tuxapp.parse_url(page_url).scheme, url) \
    if url.startswith("//") else \
  "{0.scheme}://{0.netloc}{1}".format(tuxapp.parse_url(page_url), normalize_url_path(url)) \
    if url.startswith('/') else \
  "{0.scheme}://{0.netloc}{1}".format(
    tuxapp.parse_url(base_url or parse_base_url(page_url)),
    normalize_url_path("/{}/{}".format(os.path.dirname(tuxapp.parse_url(base_url or parse_base_url(page_url)).path), url)),
  )

normalize_url_path = lambda path: \
  "{}{}".format(
    re.sub(r"^//", '/', os.path.normpath(path)),
    '/' if path and path[-1] == '/' else '',
  )

open_url = tuxapp.does(lambda url, *args, **kwargs: url and input_boolean("Open {} in the browser?".format(url)) and tuxapp.call_process("xdg-open {} > /dev/null 2>&1 &".format(tuxapp.quote_argument(url))))(lambda url: url)

parse_base_url = lambda url: normalize_url(url, parse_html(BaseURLParser, fetch_url(url)) or url, url)

parse_description = lambda url: parse_html(DescriptionParser, fetch_url(url))

parse_icon_url = lambda url: normalize_url(url, parse_html(IconURLParser, fetch_url(url)) or "/favicon.ico")

parse_name = lambda url: \
  check_name(url, tuxapp.parse_url(url).path.lstrip('/').split('/', 1)[0]) \
    if ".github.io/" in url and tuxapp.parse_url(url).path.lstrip('/') else \
  parse_html(NameParser, fetch_url(url)) or check_name(url, extract_url_name(url))

parse_title = lambda url: parse_html(TitleParser, fetch_url(url))

update_app = lambda appfile: update_appfile(appfile, 'app', input_app(filter_app(appfile.get('name', ''))))

update_appfile = tuxapp.logs_result(
  lambda *args, **kwargs: \
    u"> {}:\n{}".format(
      tuxapp.get_appfile_path(kwargs['result']['app']).replace(os.path.expanduser('~'), '~', 1),
      '\n'.join(u"> {}".format(line) for line in generate_appfile(kwargs['result']).splitlines()),
    )
)(
  lambda appfile, key, value: \
    write_appfile(dict(appfile, **{key: value})) and \
    dict(appfile, **{key: value})
)

update_category = lambda appfile: update_appfile(appfile, 'category', input_category(appfile.get('category', '')))

update_description = lambda appfile: update_appfile(appfile, 'description', input_description(appfile['app'], appfile.get('description', filter_description(parse_description(appfile['homepage-url'])))))

update_download_x86_64_url = lambda appfile: update_appfile(appfile, 'download-x86-64-url', input_download_url(appfile['app'], 'x86-64', appfile.get('download-x86-64-url', '')))

update_download_x86_url = lambda appfile: update_appfile(appfile, 'download-x86-url', input_download_url(appfile['app'], 'x86', appfile.get('download-x86-url', '')))

update_executable = lambda appfile: update_appfile(appfile, 'executable', input_executable(appfile['app'], appfile.get('executable', '')))

update_free_license = lambda appfile: update_appfile(appfile, 'free-license', input_free_license(appfile.get('free-license', 'yes')))

update_group = lambda appfile: update_appfile(appfile, 'group', input_group(appfile.get('group', '')))

update_homepage_url = lambda appfile: update_appfile(appfile, 'homepage-url', input_homepage_url(appfile.get('homepage-url', '')))

update_icon_url = lambda appfile: update_appfile(appfile, 'icon-url', input_icon_url(appfile.get('icon-url') or open_url(filter_url(parse_icon_url(appfile['homepage-url'])))))

update_name = lambda appfile: update_appfile(appfile, 'name', input_name(appfile['app'], appfile.get('name', filter_name(parse_name(appfile['homepage-url'])))))

update_title = lambda appfile: update_appfile(appfile, 'title', input_title(appfile['app'], appfile.get('title', filter_title(parse_title(appfile['homepage-url'])))))

update_version_url = lambda appfile: update_appfile(appfile, 'version-url', input_version_url(appfile['homepage-url'], appfile.get('version-url', '')))

update_version_regex = lambda appfile: update_appfile(appfile, 'version-regex', input_version_regex(appfile['app'], appfile.get('version-regex', detect_version_regex(fetch_url(appfile.get('version-url') or appfile['homepage-url'])))))

write_appfile = lambda appfile: \
  tuxapp.remove_file(tuxapp.get_appfile_path(get_default_app())) and \
  tuxapp.write_file(tuxapp.get_appfile_path(appfile['app']), u"{}\n".format(generate_appfile(dict(dict.fromkeys(validate.get_appfile_keys(), ''), **appfile))))

if __name__ == '__main__':
  main()
