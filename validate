#!/usr/bin/env python
from __future__ import print_function
import functools
import glob
import imp
import os
import re
import sys

tuxapp = imp.load_source('tuxapp', os.path.join(os.path.dirname(__file__), 'tuxapp'))

def reasserts(message):
  def decorator(function):
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
      try:
        return function(*args, **kwargs)
      except AssertionError as exception:
        exception_message = "{}{}".format(exception.args[0][0].lower(), exception.args[0][1:]) if exception.args else "unknown error"
        formatted_message = message(*args, message=exception_message, **kwargs) if hasattr(message, '__call__') else message.format(*args, message=exception_message, **kwargs)
        print(formatted_message.encode('utf-8'), file=sys.stderr)
    return wrapper
  return decorator

@tuxapp.memoizes()
@tuxapp.logs("Checking {}")
def check_url(url):
  import ssl
  try:
    from http.client import BadStatusLine
    from urllib.request import Request, URLError, urlopen
  except ImportError:
    from httplib import BadStatusLine
    from urllib2 import Request, URLError, urlopen
  try:
    return urlopen(Request(url, headers={'User-Agent': "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"})).getcode() == 200
  except (BadStatusLine, URLError, ssl.CertificateError):
    return False

def validate_appfile_worker(app):
  return validate_appfile(app)

@tuxapp.silences
def validate_appfiles(apps):
  import contextlib
  import multiprocessing
  with contextlib.closing(multiprocessing.Pool(10)) as pool:
    return functools.reduce(lambda result, is_valid: result and is_valid, pool.imap_unordered(validate_appfile_worker, apps), True)

@tuxapp.asserts("Malformed pattern")
def validate_regex(pattern):
  try:
    return bool(re.compile(pattern))
  except re.error:
    return False

check_appfile_exists = tuxapp.asserts("{}: unknown app")(
  lambda app: os.path.isfile(tuxapp.get_appfile_path(app)) and app
)

check_page_contains = lambda url, string, is_case_sensitive=False: \
  bool(re.search(
    r"\b{}\b".format(re.escape(re.sub(r"\s+", ' ', re.sub(r"\W+", ' ', string)))),
    fetch_url_text(url),
    0 if is_case_sensitive else re.I | re.U,
  ))

check_url_protocol = lambda url: url.startswith("https://") or not check_url(url.replace("http://", "https://", 1))

fetch_url_text = tuxapp.memoizes()(
  lambda url: re.sub(r"\s+", ' ', re.sub(r"\W+", ' ', re.sub(r"&[\w#]+;", ' ', re.sub(r"<(?!meta)[^>]+>", ' ', tuxapp.fetch_url(url)))))
)

get_appfile_keys = lambda: \
  (
    'category',
    'description',
    'download-x86-64-url',
    'download-x86-url',
    'executable',
    'firejail',
    'free-license',
    'group',
    'homepage-url',
    'icon-url',
    'name',
    'note',
    'packages',
    'title',
    'version-regex',
    'version-url',
  )

get_categories = lambda: \
  (
    'audio',
    'development',
    'education',
    'game',
    'graphics',
    'network',
    'office',
    'science',
    'settings',
    'system',
    'utility',
    'video',
  )

get_groups = lambda: \
  (
    'audio-streaming',
    'code-editors',
    'content-management',
    'e-book-readers',
    'email-clients',
    'instant-messengers',
    'note-taking',
    'office-suits',
    'role-playing',
    'version-control',
    'video-streaming',
    'web-browsers',
    'web-development',
  )

get_punctuation = lambda: ('.', '!', '?')

is_url_valid = lambda url: not re.search(r"\s", url) and tuxapp.parse_url(url).scheme in ('http', 'https') and bool(tuxapp.parse_url(url).netloc)

main = tuxapp.handles_exceptions(
  lambda arguments=tuple(sys.argv[1:]): validate_appfiles(tuple(check_appfile_exists(tuxapp.extract_app(argument)) for argument in arguments) or (tuxapp.extract_app(path) for path in glob.iglob(tuxapp.get_appfile_path('*'))))
)

parse_appfile = lambda app: tuple(line.split('=', 1) for line in read_appfile(app).splitlines())

parse_appfile_keys = lambda app: tuple(key for key, _ in parse_appfile(app))

read_appfile = lambda app: tuxapp.read_file(tuxapp.get_appfile_path(app))

validate_app = lambda app: \
  tuxapp.asserts("Invalid characters")(lambda app: bool(re.match("^[a-z0-9-]*$", app)))(app) and \
  tuxapp.asserts("Edge dash")(lambda app: not app.startswith('-') and not app.endswith('-'))(app) and \
  tuxapp.asserts("Continuous dashes")(lambda app: not re.search(r"-{2}", app))(app)

validate_appfile = lambda app: \
  reasserts("{}: {message}")(validate_app)(app) and \
  reasserts("{}: {message}")(validate_appfile_keys)(app) and \
  all(reasserts(u"{}.{}: {{message}}{}".format(
    app,
    key,
    u" ({})".format(value.replace('{', "{{").replace('}', "}}")) if value else '',
  ))(validate_appfile_item)(app, key, value) for key, value in parse_appfile(app))

validate_appfile_item = tuxapp.asserts("Unknown key")(
  lambda app, key, value: \
    validate_category(value) \
      if key == 'category' else \
    validate_description(app, value) \
      if key == 'description' else \
    all(validate_download_url(app, url, re.sub(r"^download-(.+)-url", r'\1', key)) for url in value.split()) \
      if key.startswith('download-') and key.endswith('-url') else \
    validate_executable(value) \
      if key == 'executable' else \
    validate_firejail(value) \
      if key == 'firejail' else \
    validate_free_license(value) \
      if key == 'free-license' else \
    validate_homepage_url(value) \
      if key == 'homepage-url' else \
    validate_icon_url(value) \
      if key == 'icon-url' else \
    validate_group(value) \
      if key == 'group' else \
    validate_name(app, value) \
      if key == 'name' else \
    validate_note(value) \
      if key == 'note' else \
    validate_packages(value) \
      if key == 'packages' else \
    validate_title(app, value) \
      if key == 'title' else \
    validate_version_regex(app, value) \
      if key == 'version-regex' else \
    validate_version_url(value) \
      if key == 'version-url' else \
    None
)

validate_appfile_keys = lambda app: \
  tuxapp.asserts("Extra lines")(lambda app: all('=' in line for line in read_appfile(app).splitlines()))(app) and \
  tuxapp.asserts("No trailing newline")(lambda app: read_appfile(app).endswith('\n'))(app) and \
  tuxapp.asserts("Not sorted")(lambda app: parse_appfile_keys(app) == tuple(sorted(parse_appfile_keys(app))))(app) and \
  tuxapp.asserts("Extraneous keys")(lambda app: not set(parse_appfile_keys(app)) - set(get_appfile_keys()))(app) and \
  tuxapp.asserts("Missing keys")(lambda app: not set(get_appfile_keys()) - set(parse_appfile_keys(app)))(app) and \
  tuxapp.asserts("Duplicated keys")(lambda app: sorted(set(parse_appfile_keys(app))) == sorted(parse_appfile_keys(app)))(app) and \
  tuxapp.asserts("Unknown error")(lambda app: parse_appfile_keys(app) == get_appfile_keys())(app)

validate_capitalized = tuxapp.asserts("Not capitalized")(
  lambda string: string[0] == string[0].upper()
)

validate_category = lambda category: \
  validate_text(category) and \
  tuxapp.asserts("Unknown category")(lambda category: category in get_categories())(category)

validate_command = tuxapp.asserts("Failed to parse")(
  lambda command: bool(tuxapp.unasserts(tuxapp.split_command)(command))
)

validate_description = lambda app, description: \
  not description or \
  validate_text(description) and \
  validate_capitalized(description) and \
  validate_terminal_punctuation(description) and \
  validate_homepage_contains(app, description)

validate_download_url = lambda app, url, architecture: \
  architecture != 'x86-64' and not url or \
  tuxapp.asserts("Contains the version number")(lambda app: tuxapp.fetch_app_version(app) not in url)(app) and \
  validate_url(tuxapp.filter_app_download_url(app, url))

validate_executable = lambda command: \
  not command or \
  validate_text(command) and \
  validate_command(command) and \
  tuxapp.asserts("Malformed path")(lambda command: bool(re.match(r"^(/|\./)?[\w/-]+$", command.split(' ', 1)[0])))(command)

validate_firejail = lambda options: \
  not options or \
  validate_text(options) and \
  validate_command(options)

validate_free_license = lambda value: \
  not value or \
  validate_text(value) and \
  tuxapp.asserts("Value is not 'yes'")(lambda value: value == 'yes')(value)

validate_group = lambda group, is_permissive=False: \
  validate_text(group) and \
  (is_permissive or tuxapp.asserts("Unknown group")(lambda group: group in get_groups())(group))

validate_homepage_contains = tuxapp.asserts("Not found on the homepage")(
  lambda app, string, is_case_sensitive=False: check_page_contains(tuxapp.query_appfile(app, 'homepage-url'), string, is_case_sensitive)
)

validate_homepage_url = lambda url: validate_url(url)

validate_icon_url = lambda url: validate_url(url)

validate_name = lambda app, name: \
  validate_text(name) and \
  validate_terminal_punctuation(name, True) and \
  (name.startswith('~') or validate_homepage_contains(app, name, True))

validate_note = lambda note: \
  not note or \
  validate_text(note) and \
  validate_capitalized(note) and \
  validate_terminal_punctuation(note)

validate_packages = lambda packages: \
  not packages or \
  validate_text(packages) and \
  tuxapp.asserts("Not sorted")(lambda packages: packages.split() == sorted(packages.split()))(packages) and \
  tuxapp.asserts("Unknown group")(lambda packages: all(package in tuxapp.get_package_groups() for package in packages.split() if package.startswith('group-')))(packages) and \
  tuxapp.asserts("Duplicated items")(lambda packages: sorted(set(packages.split())) == sorted(packages.split()))(packages) and \
  tuxapp.asserts("Group already contains a package")(lambda packages: not set(packages.split()) & set(package for package in packages.split() if package.startswith('group-') for package in tuxapp.expand_package(package)))(packages) and \
  tuxapp.asserts("Unknown package")(lambda packages: all(tuxapp.unasserts(tuxapp.parse_package_lists)(package) for package in packages.split() if not package.startswith('group-')))(packages)

validate_terminal_punctuation = tuxapp.asserts(lambda string, is_inverted=False, *args, **kwargs: "Terminal punctuation" if is_inverted else "No terminal punctuation")(
  lambda string, is_inverted=False: (string[-1] in get_punctuation()) ^ is_inverted
)

validate_text = lambda string, is_whitespacy=False: \
  tuxapp.asserts("Is required")(lambda string: bool(string))(string) and \
  tuxapp.asserts("Tab character")(lambda string: '\t' not in string)(string) and \
  tuxapp.asserts("Edge whitespace")(lambda string, is_whitespacy: is_whitespacy or not re.search(r"^\s", string) and not re.search(r"\s$", string))(string, is_whitespacy) and \
  tuxapp.asserts("Continuous whitespace")(lambda string, is_whitespacy: is_whitespacy or not re.search(r"\s{2}", string))(string, is_whitespacy)

validate_title = lambda app, title: \
  not title or \
  validate_text(title) and \
  validate_capitalized(title) and \
  validate_terminal_punctuation(title, True) and \
  validate_homepage_contains(app, title)

validate_url = lambda url: \
  validate_text(url) and \
  tuxapp.asserts("Invalid URL")(is_url_valid)(url) and \
  tuxapp.asserts("No path")(lambda url: bool(tuxapp.parse_url(url).path))(url) and \
  tuxapp.asserts("Contains a fragment")(lambda url: '#' not in url)(url) and \
  tuxapp.asserts("Not ends with /latest")(lambda url: not re.search(r"\bgithub\.com/[\w-]+/[\w-]+/releases(?!/latest$)", url))(url) and \
  tuxapp.asserts("Accessible by HTTPS")(check_url_protocol)(url) and \
  tuxapp.asserts("Inaccessible URL")(check_url)(url)

validate_version_regex = lambda app, pattern: \
  validate_text(pattern, True) and \
  validate_regex(pattern) and \
  tuxapp.asserts("No grouping parentheses")(lambda pattern: bool(re.search(r"\((?!\?)", pattern)) and ')' in pattern)(pattern) and \
  bool(tuxapp.fetch_app_version(app, pattern))

validate_version_url = lambda url: not url or validate_url(url)

if __name__ == '__main__':
  main()
