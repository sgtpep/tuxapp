#!/usr/bin/env python
from __future__ import print_function
import argparse
import distutils.spawn
import glob
import mmap
import os
import platform
import re
import shutil
import subprocess
import sys
import time

try:
  from shlex import quote
except ImportError:
  from pipes import quote
try:
  from urllib.parse import urlparse
except ImportError:
  from urlparse import urlparse

map(lambda environment_variable: os.environ.setdefault(environment_variable[0], os.path.expanduser(environment_variable[1])), {
  'XDG_CACHE_HOME': "~/.cache",
  'XDG_DATA_HOME': "~/.local/share",
}.items())

BASE_PATH = os.path.expanduser("~/.tuxapp")
CACHE_PATH = os.path.expandvars("$XDG_CACHE_HOME/tuxapp")
CURL_OPTIONS = ['-#Lf', '-H', "Accept-Language: en", '-m', '10', '--retry', '2']
DATA_PATH = os.path.expandvars("$XDG_DATA_HOME")
DEBIAN_MIRROR_URL = "https://cdn-aws.deb.debian.org/"
DEBIAN_RELEASE_NAME = 'stretch'
GITHUB_REPOSITORY = "sgtpep/tuxapp"
WGET_OPTIONS = ['-T', '10', '-t', '3', '-nv', '--header', "Accept-Language: en"]
__version__ = "1.0.0"

class TuxappException(Exception):
  pass

def change_file_mode(file_path, get_file_mode): # pylint: disable=imperative-function-body
  os.chmod(file_path, get_file_mode(os.stat(file_path).st_mode))
  return file_path

def check_installed_app(app_id):
  return app_id if os.path.isfile("{}/{}/version".format(BASE_PATH, app_id)) \
    else raise_exception("{} is not installed".format(app_id))

def check_parsed_arguments(parsed_arguments):
  is_no_argument_required = parsed_arguments.is_list_all_apps \
    or parsed_arguments.is_list_installed_apps \
    or parsed_arguments.is_purge_cache
  is_argument_required = parsed_arguments.is_run_app \
    or parsed_arguments.is_uninstall_apps
  return raise_exception("This action takes no arguments") if is_no_argument_required \
    and parsed_arguments.apps \
    else raise_exception("This action requires an argument") if is_argument_required \
    and not parsed_arguments.apps \
    else parsed_arguments

def check_updated_app(app_id):
  app_id_installed = check_installed_app(app_id)
  app_info = read_app_info(app_id_installed)
  app_version_installed = read_app_version(app_id_installed)
  app_version_released = fetch_url_match_version_throttled(app_id_installed, app_info['version-url'], app_info['version-regex'])
  return app_version_installed != app_version_released \
    and log_message("{} can be updated from {} to {}".format(app_id_installed, app_version_installed, app_version_released))

def check_updated_apps(app_ids=[]):
  app_ids_installed = map(check_installed_app, app_ids) if app_ids \
    else get_installed_apps()
  updated_app_ids = filter(check_updated_app, app_ids_installed)
  message_text = "Updates available: {}".format(", ".join(updated_app_ids)) if updated_app_ids \
    else "No updates"
  return log_message(message_text) \
    and bool(updated_app_ids)

def copy_file(source_file, destination_file, source_offset=0, source_size=None, chunk_size=65536): # pylint: disable=imperative-function-body
  with source_file, destination_file:
    source_file.seek(source_offset)
    if source_size:
      [destination_file.write(source_file.read(chunk_size)) for _ in xrange(source_size / chunk_size)]
      destination_file.write(source_file.read(source_size % chunk_size))
    else:
      shutil.copyfileobj(source_file, destination_file, chunk_size)
  return True

def detect_architecture_name():
  machine_name = platform.machine()
  return {
    'i386': 'x86',
    'i686': 'x86',
    'ia64': 'x86-64',
    'x86_64': 'x86-64',
  }.get(machine_name, raise_exception("Unknown architecture: {}".format(machine_name)))

def detect_debian_architecture_name():
  return {
    'x86': 'i386',
    'x86-64': 'amd64',
  }[detect_architecture_name()]

def download_file(url, download_path=None, exception_text=None):
  target_path = download_path \
    or get_url_cache_path(url)
  output_path = make_file_directories("{}/downloads/{}".format(CACHE_PATH, os.path.basename(target_path)))
  request_arguments = get_request_arguments(['-o', output_path, url], ['-O', output_path, '--show-progress', url])
  command_exception_text = "Failed to download {}".format(url) if exception_text is None \
    else exception_text
  return run_command(request_arguments, "Downloading {}".format(url), command_exception_text) \
    and rename_file(output_path, target_path)

def download_file_needed(url, download_path=None, exception_text=None):
  target_path = download_path \
    or get_url_cache_path(url)
  return target_path if os.path.isfile(target_path) \
    else download_file(url, target_path, exception_text)

def exec_command(command_arguments, environment_variables={}): # pylint: disable=imperative-function-body
  if environment_variables:
    process_environment_variables = os.environ.copy()
    process_environment_variables.update(environment_variables)
    os.execvpe(command_arguments[0], command_arguments, process_environment_variables)
  else:
    os.execvp(command_arguments[0], command_arguments)

def extract_debian_package(debian_package_path, output_path, is_silent=False):
  debian_package_info = extract_debian_package_parse_info(debian_package_path)
  tar_filter_option = {
    'bz2': '-j',
    'gz': '-z',
    'lzma': '--lzma',
    'xz': '-J',
  }[debian_package_info['data_extension']]
  tar_progress_options = [] if is_silent \
    else ["--checkpoint=.250"]
  tar_arguments = [
    'tar', '-x', tar_filter_option, '-C', make_directories(output_path),
    "--exclude=./usr/share/doc",
    "--exclude=./usr/share/doc-base",
    "--exclude=./usr/share/lintian,man",
    "--exclude=./usr/share/man",
  ] + tar_progress_options
  tar_process = log_message("Extracting {}".format(os.path.basename(debian_package_path)), is_silent=is_silent) \
    and subprocess.Popen(tar_arguments, stdin=subprocess.PIPE)
  return copy_file(open(debian_package_path, 'rb'), tar_process.stdin, debian_package_info['data_offset'], debian_package_info['data_size']) \
    and (tar_process.wait() == 0 \
    or raise_exception("Failed to execute command: {}".format(quote_command_arguments(tar_arguments)))) \
    and log_message(is_silent=is_silent) \
    and output_path

def extract_debian_package_parse_info(debian_package_path): # pylint: disable=imperative-function-body
  with open(debian_package_path, 'rb') as debian_package_file:
    debian_package_memory_map = mmap.mmap(debian_package_file.fileno(), 0, access=mmap.ACCESS_READ)
    debian_package_data_header_start = debian_package_memory_map.find(b"data.tar.")
    debian_package_data_header_end = (debian_package_data_header_start != -1 \
      or raise_exception("Failed to parse the debian package info from {}".format(os.path.basename(debian_package_path)))) \
      and debian_package_memory_map.find(b'`', debian_package_data_header_start)
    debian_package_data_filename, _, _, _, _, debian_package_data_size, _ = re.split(r"\s+", debian_package_memory_map[debian_package_data_header_start:debian_package_data_header_end].decode('utf8'))
    debian_package_memory_map.close()
  return {
    'data_extension': os.path.splitext(debian_package_data_filename)[1][1:],
    'data_offset': debian_package_data_header_end + 2,
    'data_size': int(debian_package_data_size),
  }

def extract_tarball(tarball_path, output_path, tar_options=[], is_silent=False):
  tar_progress_options = [] if is_silent \
    else ["--checkpoint=.250"]
  tar_arguments = ['tar', '-x', '-C', make_directories(output_path), '-f', tarball_path] + tar_progress_options + tar_options
  message_text = not is_silent \
    and "Extracting {}".format(os.path.basename(tarball_path))
  return run_command(tar_arguments, message_text) \
    and log_message(is_silent=is_silent) \
    and output_path

def fetch_url(url, exception_text=None):
  request_arguments = get_request_arguments(['-Ss', url], ['-q', '-O', '-', url])
  command_exception_text = "Failed to fetch {}".format(url) if exception_text is None \
    else exception_text
  return run_command(request_arguments, "Fetching {}".format(url), command_exception_text, is_output=True)

def fetch_url_grep(url, grep_arguments, exception_text=None):
  request_arguments = get_request_arguments(['-Ss', url], ['-q', '-O', '-', url])
  shell_command = "{} | grep {}".format(quote_command_arguments(request_arguments), quote_command_arguments(grep_arguments))
  command_exception_text = "Failed to fetch {}".format(url) if exception_text is None \
    else exception_text
  command_output = run_command(shell_command, "Fetching {}".format(url), command_exception_text, is_output=True)
  return command_output[:-1] if is_string(command_output) \
    else command_output

def fetch_url_match_version(url, version_pattern, exception_text=None):
  request_arguments = get_request_arguments(['-Ss', '-D', '-', url], ['-Sq', '-O', '-', url])
  request_command_redirect = "2>&1" if request_arguments[0] == 'wget' \
    else ''
  grep_pattern = re.sub(r"^(.*?)(?<!\\)\(", r"(?<=\1)", re.sub(r"(?<!\\)\)(.*?)$", r"(?=\1)", version_pattern, 1), 1)
  shell_command = "{} {} | head -c 1000000 2> /dev/null | grep -Pao -m 1 {}".format(quote_command_arguments(request_arguments), request_command_redirect, quote(grep_pattern))
  command_exception_text = "Unable to determine an app version from {}".format(url) if exception_text is None \
    else exception_text
  command_output = run_command(shell_command, "Fetching {}".format(url), command_exception_text, is_output=True)
  return ''.join(command_output.splitlines()[:1]) if is_string(command_output) \
    else command_output

def fetch_url_match_version_throttled(app_id, url, version_pattern, exception_text=None):
  app_version_path = "{}/{}/version".format(BASE_PATH, app_id)
  is_app_version_old = time.time() - os.path.getmtime(app_version_path) > 60
  app_version_installed = read_app_version(app_id)
  app_version_released = fetch_url_match_version(url, version_pattern, exception_text) if is_app_version_old \
    else app_version_installed
  return (not is_app_version_old \
    or app_version_installed != app_version_released \
    or touch_file(app_version_path)) \
    and app_version_released

def filter_app_id(app):
  return app.split('/')[-1]

def get_installed_apps():
  return [os.path.basename(os.path.dirname(app_version_path)) for app_version_path in glob.glob("{}/*/version".format(BASE_PATH))] \
    or raise_exception("No apps installed")

def get_request_arguments(curl_options=[], wget_options=[]):
  return ['wget'] + WGET_OPTIONS + wget_options if is_command_executable('wget') and not os.environ.get('TUXAPP_CURL') \
    else ['curl'] + CURL_OPTIONS + curl_options if is_command_executable('curl') \
    else raise_exception("Neither wget nor curl is installed")

def get_url_cache_path(url):
  return "{}/{}".format(CACHE_PATH, os.path.basename(urlparse(url).path))

def handle_exceptions(function): # pylint: disable=imperative-function-body
  def wrapper(*args, **kwargs): # pylint: disable=imperative-function-body
    try:
      return function(*args, **kwargs)
    except KeyboardInterrupt:
      return log_message("\nInterrupted") \
        and sys.exit(130)
    except TuxappException as tuxapp_exception:
      return log_message(tuxapp_exception.args[0], is_silent=not tuxapp_exception.args) \
        and sys.exit(1)
  return wrapper

def install_app(app_id, firejail_value=None):
  print(app_id)
  return True

def install_apps(app_ids=[], firejail_value=None):
  app_ids_install = app_ids \
    or get_installed_apps()
  return install_common() \
    and all(map(install_app, app_ids_install))

def install_common():
  print('common')
  return True

def is_command_executable(executable_name):
  return bool(distutils.spawn.find_executable(executable_name))

def is_string(value):
  return isinstance(value, (''.__class__, u''.__class__))

def list_all_apps():
  message_text = fetch_url_grep("https://api.github.com/repos/{}/contents/apps".format(GITHUB_REPOSITORY), ['-Po', "(?<=\"name\": \")[^\"]+"], "Failed to get a list of apps")
  return output_message(message_text)

def list_installed_app(app_id):
  app_version = read_app_version(app_id)
  return output_message("{} {}".format(app_id, app_version))

def list_installed_apps():
  app_ids = get_installed_apps()
  return all(map(list_installed_app, app_ids))

def log_message(message_text='', is_silent=False): # pylint: disable=imperative-function-body
  is_silent or \
    print(message_text, file=sys.stderr)
  return True

@handle_exceptions
def main():
  parsed_arguments = parse_arguments(sys.argv[1:])
  app_ids = map(filter_app_id, parsed_arguments.apps)
  firejail_options = True if parsed_arguments.firejail_options in ('', 'on') \
    else False if parsed_arguments.firejail_options == 'off' \
    else parsed_arguments.firejail_options
  print(firejail_options)
  return check_updated_apps(app_ids) if parsed_arguments.is_check_updated_apps \
    else install_apps(app_ids, parsed_arguments.firejail_options) if parsed_arguments.is_install_apps \
    else list_all_apps() if parsed_arguments.is_list_all_apps \
    else list_installed_apps() if parsed_arguments.is_list_installed_apps \
    else purge_cache() if parsed_arguments.is_purge_cache \
    else run_app(app_ids[0], parsed_arguments.apps[1:], parsed_arguments.firejail_options) if parsed_arguments.is_run_app \
    else uninstall_apps(app_ids) if parsed_arguments.is_uninstall_apps \
    else raise_exception("Unknown action")

def make_directories(directory_path): # pylint: disable=imperative-function-body
  os.path.isdir(directory_path) \
    or os.makedirs(directory_path)
  return directory_path

def make_file_directories(file_path):
  return make_directories(os.path.dirname(file_path)) \
    and file_path

def output_message(message_text='', is_silent=False): # pylint: disable=imperative-function-body
  is_silent or \
    print(message_text)
  return True

def parse_arguments(arguments): # pylint: disable=imperative-function-body
  argument_parser = argparse.ArgumentParser(description=u"%(prog)s downloads and installs the latest official releases of Linux\N{COPYRIGHT SIGN} applications including dependencies without root permissions and allows to run them sandboxed.", epilog="ISC License, (c) 2017 Danil Semelenov, https://github.com/{}".format(GITHUB_REPOSITORY))
  argument_parser.add_argument('-a', '--all', action='store_true', dest='is_list_all_apps', help="list apps available for installation")
  argument_parser.add_argument('-c', '--check', action='store_true', dest='is_check_updated_apps', help="check installed apps for updates")
  argument_parser.add_argument('-f', '--firejail', dest='firejail_options', help="set permanent firejail options for apps on --install, or set temporary firejail options for an app on --run; pass 'off' to disable firejail or 'on' to enable it")
  argument_parser.add_argument('-i', '--install', action='store_true', dest='is_install_apps', help="install or update apps; update all installed apps if no arguments are provided")
  argument_parser.add_argument('-l', '--list', action='store_true', dest='is_list_installed_apps', help="list installed apps")
  argument_parser.add_argument('-p', '--purge', action='store_true', dest='is_purge_cache', help="purge cache")
  argument_parser.add_argument('-r', '--run', action='store_true', dest='is_run_app', help="run an installed app")
  argument_parser.add_argument('-u', '--uninstall', action='store_true', dest='is_uninstall_apps', help="uninstall installed apps")
  argument_parser.add_argument('-v', '--version', action='version', version="%(prog)s {}".format(__version__))
  argument_parser.add_argument('apps', help="an app identifier", metavar='app', nargs='*')
  parsed_arguments = argument_parser.parse_args(arguments \
    or ['-h'])
  return check_parsed_arguments(parsed_arguments)

def purge_cache():
  return remove_directory(CACHE_PATH) \
    and log_message("Purged cache")

def quote_command_arguments(command_arguments):
  return ' '.join(map(quote, command_arguments))

def raise_exception(exception_text=None): # pylint: disable=imperative-function-body
  raise TuxappException(exception_text) if exception_text \
    else TuxappException

def read_app_info(app_id):
  app_info_path = "{}/apps/{}".format(os.path.dirname(__file__), app_id)
  app_info_contents = read_file(app_info_path) if os.path.isfile(app_info_path) \
    else fetch_url("https://raw.githubusercontent.com/{}/master/apps/{}".format(GITHUB_REPOSITORY, app_id), "{} was not found".format(app_id))
  return dict(app_info_line.split('=', 1) for app_info_line in app_info_contents.splitlines())

def read_app_version(app_id):
  return read_file("{}/{}/version".format(BASE_PATH, app_id)).rstrip()

def read_file(file_path): # pylint: disable=imperative-function-body
  if os.path.isfile(file_path):
    with open(file_path) as file_file:
      return file_file.read()

def remove_directory(directory_path): # pylint: disable=imperative-function-body
  os.path.isdir(directory_path) \
    and shutil.rmtree(directory_path)
  return True

def remove_file(file_path): # pylint: disable=imperative-function-body
  os.path.isfile(file_path) \
    and os.remove(file_path)
  return True

def rename_file(source_path, destination_path): # pylint: disable=imperative-function-body
  target_path = make_file_directories(destination_path)
  os.rename(source_path, target_path)
  return target_path

def run_app(app_id, app_arguments=[], firejail_value=None):
  app_id_installed = check_installed_app(app_id)
  command_arguments = ["{}/{}/run".format(BASE_PATH, app_id_installed)] + app_arguments
  return tuxapp.exec_command(command_arguments)

def run_command(command_arguments, message_text=None, exception_text=None, is_output=False): # pylint: disable=imperative-function-body
  try:
    return run_command_try(command_arguments, message_text, is_output)
  except subprocess.CalledProcessError:
    quoted_command_arguments = command_arguments if is_string(command_arguments) \
      else quote_command_arguments(command_arguments)
    command_exception_text = exception_text \
      or "Failed to execute command: {}".format(quoted_command_arguments)
    return not exception_text is False \
      and raise_exception(command_exception_text)

def run_command_try(command_arguments, message_text=None, is_output=False):
  is_shell_command = is_string(command_arguments)
  return log_message(message_text, is_silent=not message_text) \
    and (subprocess.check_output(command_arguments, shell=is_shell_command).decode('utf8') if is_output \
    else subprocess.check_call(command_arguments, shell=is_shell_command) == 0)

def touch_file(file_path, file_timestamp=None): # pylint: disable=imperative-function-body
  file_timestamps = None if file_timestamp is None \
    else (file_timestamp, file_timestamp)
  os.utime(file_path, file_timestamps)
  return True

def uninstall_app(app_id):
  app_id_installed = check_installed_app(app_id)
  return remove_file("{}/icons/tuxapp-{}".format(DATA_PATH, app_id_installed)) \
    and remove_file("{}/applications/tuxapp-{}.desktop".format(DATA_PATH, app_id_installed)) \
    and remove_directory("{}/{}".format(BASE_PATH, app_id_installed)) \
    and log_message("Uninstalled {}".format(app_id_installed))

def uninstall_apps(app_ids):
  return all(map(check_installed_app, app_ids)) \
    and all(map(uninstall_app, app_ids))

def write_file(file_path, file_contents=''): # pylint: disable=imperative-function-body
  if read_file(file_path) != file_contents:
    with open(make_file_directories(file_path), 'w') as file_file:
      file_file.write(file_contents)
  return file_path

__name__ == '__main__' and main()
