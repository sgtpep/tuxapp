#!/usr/bin/env python
from __future__ import print_function
import functools
import glob
import imp
import os
import re
import sys

try:
  from urllib.parse import urlparse
except ImportError:
  from urlparse import urlparse

tuxapp = imp.load_source('tuxapp', "{}/tuxapp".format(os.path.dirname(__file__)))

def overrides_message(message):
  def decorator(function):
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
      try:
        return function(*args, **kwargs)
      except AssertionError as exception:
        kwargs['message'] = "{}{}".format(exception.args[0][0].lower(), exception.args[0][1:])
        formatted_message = message(*args, **kwargs) if hasattr(message, '__call__') else message.format(*args, **kwargs)
        raise AssertionError(formatted_message.encode('utf-8'))
    return wrapper
  return decorator

def check_appfile_wrapper(app):
  return check_appfile(app)

@tuxapp.memoizes()
@tuxapp.logs("Checking {}")
def check_url_status(url):
  import ssl
  try:
    from http.client import BadStatusLine
    from urllib.request import Request, URLError, urlopen
  except ImportError:
    from httplib import BadStatusLine
    from urllib2 import Request, URLError, urlopen
  try:
    return urlopen(Request(url, headers={'User-Agent': "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"})).getcode() == 200
  except (BadStatusLine, URLError, ssl.CertificateError):
    return False

@tuxapp.silences
def check_appfiles(apps):
  import contextlib
  import multiprocessing
  with contextlib.closing(multiprocessing.Pool(10)) as pool:
    return all(pool.imap_unordered(check_appfile_wrapper, apps))

check_app = lambda app: \
  tuxapp.asserts("Invalid characters")(lambda: bool(re.match("^[a-z0-9-]*$", app)))() and \
  tuxapp.asserts("Edge dash")(lambda: not app.startswith('-') and not app.endswith('-'))() and \
  tuxapp.asserts("Continuous dashes")(lambda: not re.search(r"-{2}", app))()

check_appfile = lambda app: \
  overrides_message("{}: {message}")(check_app)(app) and \
  overrides_message("{}: {message}")(check_appfile_keys)(app) and \
  all(get_overrides_message(app, key, value)(check_appfile_value)(key, value) for key, value in parse_appfile(app)) and \
  all(get_overrides_message(app, key, value)(check_appfile_item)(key, value) for key, value in parse_appfile(app)) and \
  all(get_overrides_message(app, key, url)(check_url)(url) for key, url in parse_appfile_urls(app))

check_appfile_exists = tuxapp.asserts("{}: unknown app")(
  lambda app: os.path.isfile(tuxapp.get_appfile_path(app)) and app
)

check_appfile_item = tuxapp.asserts("Unknown key")(
  lambda key, value: \
    check_category(value) \
      if key == 'category' else \
    check_free_license(value) \
      if key == 'free-license' else \
    check_required(value) \
      if key == 'homepage-url' else \
    check_group(value) \
      if key == 'group' else \
    None
)

check_appfile_keys = lambda app: \
  tuxapp.asserts("Extra lines")(lambda: all('=' in line for line in read_appfile(app).splitlines()))() and \
  tuxapp.asserts("No trailing newline")(lambda: read_appfile(app).endswith('\n'))() and \
  tuxapp.asserts("Not sorted")(lambda: parse_appfile_keys(app) == tuple(sorted(parse_appfile_keys(app))))() and \
  tuxapp.asserts("Extraneous keys")(lambda: not set(parse_appfile_keys(app)) - set(get_appfile_keys()))() and \
  tuxapp.asserts("Missing keys")(lambda: not set(get_appfile_keys()) - set(parse_appfile_keys(app)))() and \
  tuxapp.asserts("Doubled keys")(lambda: parse_appfile_keys(app) == get_appfile_keys())()

check_appfile_value = lambda key, value: \
  (key == 'version-regex' or tuxapp.asserts("Edge whitespace")(lambda: not re.search(r"^\s", value) and not re.search(r"\s$", value))()) and \
  tuxapp.asserts("Continuous whitespace")(lambda: not re.search(r"\s{2}", value))() and \
  tuxapp.asserts("Tab character")(lambda: '\t' not in value)()

check_category = lambda category: \
  check_required(category) and \
  tuxapp.asserts("Unknown category")(lambda: category in get_categories())()

check_free_license = tuxapp.asserts("Wrong value")(
  lambda value: value in ('', 'yes')
)

check_group = lambda group: \
  check_required(group) and \
  tuxapp.asserts("Unknown group")(lambda: group in get_groups())()


check_required = tuxapp.asserts("Is required")(
  lambda value: bool(value)
)

check_url = lambda url: \
  tuxapp.asserts("Invalid URL")(lambda: urlparse(url).scheme in ('http', 'https') and bool(urlparse(url).netloc) and bool(urlparse(url).path))() and \
  tuxapp.asserts("URL is accessible by HTTPS")(lambda: url.startswith("https://") or not check_url_status(url.replace("http://", "https://", 1)))() and \
  tuxapp.asserts("Inaccessible URL")(check_url_status)(url)

get_appfile_keys = lambda: \
  (
    'category',
    'description',
    'download-x86-64-url',
    'download-x86-url',
    'executable',
    'firejail',
    'free-license',
    'group',
    'homepage-url',
    'icon-url',
    'name',
    'note',
    'packages',
    'title',
    'version-regex',
    'version-url',
  )

get_categories = lambda: \
  (
    'audio',
    'development',
    'education',
    'game',
    'graphics',
    'network',
    'office',
    'science',
    'settings',
    'system',
    'utility',
    'video',
  )

get_groups = lambda: \
  (
    'audio-streaming',
    'code-editors',
    'content-management',
    'e-book-readers',
    'email-clients',
    'instant-messengers',
    'note-taking',
    'office-suits',
    'role-playing',
    'version-control',
    'video-streaming',
    'web-browsers',
    'web-development',
  )

get_overrides_message = lambda app, key, value: overrides_message(u"{}.{}: {{message}} ({})".format(app, key, value))

get_appfiles = lambda: tuple(sorted(tuxapp.extract_app(path) for path in glob.glob(tuxapp.get_appfile_path('*'))))

main = tuxapp.handles_exceptions(
  lambda arguments=tuple(sys.argv[1:]): check_appfiles(tuple(check_appfile_exists(tuxapp.extract_app(argument)) for argument in arguments) or get_appfiles())
)

parse_appfile = tuxapp.memoizes()(
  lambda app: tuple(line.split('=', 1) for line in read_appfile(app).splitlines())
)

parse_appfile_keys = lambda app: tuple(key for key, _ in parse_appfile(app))

parse_appfile_urls = lambda app: tuple((key, url) for key, value in parse_appfile(app) if key.endswith('-url') and value for url in (tuple(tuxapp.filter_app_download_url(app, url) for url in value.split()) if key.startswith('download-') else (value,)))

read_appfile = lambda app: tuxapp.read_file(tuxapp.get_appfile_path(app))

if __name__ == '__main__':
  main()
