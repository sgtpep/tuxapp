#!/usr/bin/env python
from __future__ import print_function
import functools
import glob
import imp
import os
import re
import sys

try:
  from urllib.parse import urlparse
except ImportError:
  from urlparse import urlparse

tuxapp = imp.load_source('tuxapp', "{}/tuxapp".format(os.path.dirname(__file__)))

def overrides_message(message):
  def decorator(function):
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
      try:
        return function(*args, **kwargs)
      except AssertionError as exception:
        kwargs['message'] = "{}{}".format(exception.args[0][0].lower(), exception.args[0][1:])
        formatted_message = message(*args, **kwargs) if hasattr(message, '__call__') else message.format(*args, **kwargs)
        raise AssertionError(formatted_message.encode('utf-8'))
    return wrapper
  return decorator

def check_appfile_wrapped(app):
  return check_appfile(app)

@tuxapp.memoizes()
@tuxapp.logs("Checking {}")
def check_url_status(url):
  import ssl
  try:
    from http.client import BadStatusLine
    from urllib.request import Request, URLError, urlopen
  except ImportError:
    from httplib import BadStatusLine
    from urllib2 import Request, URLError, urlopen
  try:
    return urlopen(Request(url, headers={'User-Agent': "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"})).getcode() == 200
  except (BadStatusLine, URLError, ssl.CertificateError):
    return False

@tuxapp.silences
def check_appfiles(apps):
  import contextlib
  import multiprocessing
  with contextlib.closing(multiprocessing.Pool(10)) as pool:
    return all(pool.imap_unordered(check_appfile_wrapped, apps))

check_app = lambda app: \
  tuxapp.asserts("Invalid characters")(lambda: bool(re.match("^[a-z0-9-]*$", app)))() and \
  tuxapp.asserts("Edge dash")(lambda: not app.startswith('-') and not app.endswith('-'))() and \
  tuxapp.asserts("Continuous dashes")(lambda: not re.search(r"-{2}", app))()

check_appfile = lambda app: \
  overrides_message("{}: {message}")(check_app)(app) and \
  overrides_message("{}: {message}")(check_appfile_keys)(app) and \
  all(overrides_message(u"{}.{}: {{message}}{}".format(
    app,
    key,
    u" ({})".format(value.replace('{', "{{").replace('}', "}}")) if value else '',
  ))(check_appfile_item)(app, key, value) for key, value in parse_appfile(app))

check_appfile_exists = tuxapp.asserts("{}: unknown app")(
  lambda app: os.path.isfile(tuxapp.get_appfile_path(app)) and app
)

check_appfile_item = tuxapp.asserts("Unknown key")(
  lambda app, key, value: \
    check_category(value) \
      if key == 'category' else \
    check_description(app, value) \
      if key == 'description' else \
    True \
      if key == 'download-x86-64-url' else \
    True \
      if key == 'download-x86-url' else \
    True \
      if key == 'executable' else \
    True \
      if key == 'firejail' else \
    check_free_license(value) \
      if key == 'free-license' else \
    check_homepage_url(value) \
      if key == 'homepage-url' else \
    check_icon_url(value) \
      if key == 'icon-url' else \
    check_group(value) \
      if key == 'group' else \
    check_name(app, value) \
      if key == 'name' else \
    check_note(value) \
      if key == 'note' else \
    True \
      if key == 'packages' else \
    check_title(app, value) \
      if key == 'title' else \
    True \
      if key == 'version-regex' else \
    True \
      if key == 'version-url' else \
    None
)

check_appfile_keys = lambda app: \
  tuxapp.asserts("Extra lines")(lambda: all('=' in line for line in read_appfile(app).splitlines()))() and \
  tuxapp.asserts("No trailing newline")(lambda: read_appfile(app).endswith('\n'))() and \
  tuxapp.asserts("Not sorted")(lambda: parse_appfile_keys(app) == tuple(sorted(parse_appfile_keys(app))))() and \
  tuxapp.asserts("Extraneous keys")(lambda: not set(parse_appfile_keys(app)) - set(get_appfile_keys()))() and \
  tuxapp.asserts("Missing keys")(lambda: not set(get_appfile_keys()) - set(parse_appfile_keys(app)))() and \
  tuxapp.asserts("Doubled keys")(lambda: parse_appfile_keys(app) == get_appfile_keys())()

check_category = lambda category: \
  check_value(category) and \
  tuxapp.asserts("Unknown category")(lambda: category in get_categories())()

check_description = lambda app, description: \
  not description or \
  tuxapp.asserts("Not capitalized")(lambda: description[0].upper() == description[0])() and \
  tuxapp.asserts("No terminal punctuation")(lambda: description[-1] in get_terminal_punctuation())() and \
  check_homepage_contains(app, description)

check_free_license = lambda value: \
  not value or \
  tuxapp.asserts("Value is not 'yes'")(lambda: value == 'yes')()

check_group = lambda group: \
  check_value(group) and \
  tuxapp.asserts("Unknown group")(lambda: group in get_groups())()

check_homepage_contains = tuxapp.asserts("Not found on the homepage")(
  lambda app, string, is_case_sensitive=False: \
    bool(re.search(
      r"\b{}\b".format(re.escape(re.sub(r"\s+", ' ', re.sub(r"\W+", ' ', string)))),
      fetch_url_text(tuxapp.query_appfile(app, 'homepage-url')),
      0 if is_case_sensitive else re.I | re.U,
    ))
)

check_homepage_url = lambda url: \
  check_value(url) and \
  check_url(url)

check_icon_url = lambda url: \
  check_value(url) and \
  check_url(url)

check_name = lambda app, name: \
  check_value(name) and \
  (name.startswith('~') or check_homepage_contains(app, name, True))

check_note = lambda note: \
  not note or \
  tuxapp.asserts("Not capitalized")(lambda: note[0].upper() == note[0])() and \
  tuxapp.asserts("No terminal punctuation")(lambda: note[-1] in get_terminal_punctuation())()

check_title = lambda app, title: \
  not title or \
  tuxapp.asserts("Not capitalized")(lambda: title[0].upper() == title[0])() and \
  tuxapp.asserts("Terminal punctuation")(lambda: title[-1] not in get_terminal_punctuation())() and \
  check_homepage_contains(app, title)

check_url = lambda url: \
  tuxapp.asserts("Invalid URL")(lambda: urlparse(url).scheme in ('http', 'https') and bool(urlparse(url).netloc) and bool(urlparse(url).path))() and \
  tuxapp.asserts("URL is accessible by HTTPS")(lambda: url.startswith("https://") or not check_url_status(url.replace("http://", "https://", 1)))() and \
  tuxapp.asserts("Inaccessible URL")(check_url_status)(url)

check_value = lambda string: \
  tuxapp.asserts("Is required")(lambda: bool(string))() and \
  tuxapp.asserts("Edge whitespace")(lambda: not re.search(r"^\s", string) and not re.search(r"\s$", string))() and \
  tuxapp.asserts("Continuous whitespace")(lambda: not re.search(r"\s{2}", string))() and \
  tuxapp.asserts("Tab character")(lambda: '\t' not in string)()

fetch_url_text = tuxapp.memoizes()(
  lambda url: re.sub(r"\s+", ' ', re.sub(r"\W+", ' ', re.sub(r"&[\w#]+;", ' ', re.sub(r"<(?!meta)[^>]+>", ' ', tuxapp.fetch_url(url)))))
)

get_appfile_keys = lambda: \
  (
    'category',
    'description',
    'download-x86-64-url',
    'download-x86-url',
    'executable',
    'firejail',
    'free-license',
    'group',
    'homepage-url',
    'icon-url',
    'name',
    'note',
    'packages',
    'title',
    'version-regex',
    'version-url',
  )

get_appfiles = lambda: tuple(sorted(tuxapp.extract_app(path) for path in glob.glob(tuxapp.get_appfile_path('*'))))

get_categories = lambda: \
  (
    'audio',
    'development',
    'education',
    'game',
    'graphics',
    'network',
    'office',
    'science',
    'settings',
    'system',
    'utility',
    'video',
  )

get_groups = lambda: \
  (
    'audio-streaming',
    'code-editors',
    'content-management',
    'e-book-readers',
    'email-clients',
    'instant-messengers',
    'note-taking',
    'office-suits',
    'role-playing',
    'version-control',
    'video-streaming',
    'web-browsers',
    'web-development',
  )

get_terminal_punctuation = lambda: ('.', '!', '?')

main = tuxapp.handles_exceptions(
  lambda arguments=tuple(sys.argv[1:]): check_appfiles(tuple(check_appfile_exists(tuxapp.extract_app(argument)) for argument in arguments) or get_appfiles())
)

parse_appfile = lambda app: tuple(line.split('=', 1) for line in read_appfile(app).splitlines())

parse_appfile_keys = lambda app: tuple(key for key, _ in parse_appfile(app))

read_appfile = lambda app: tuxapp.read_file(tuxapp.get_appfile_path(app))

if __name__ == '__main__':
  main()
