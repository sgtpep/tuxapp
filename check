#!/usr/bin/env python
from __future__ import print_function
import functools
import glob
import imp
import os
import re
import sys

try:
  from urllib.parse import urlparse
except ImportError:
  from urlparse import urlparse

tuxapp = imp.load_source('tuxapp', "{}/tuxapp".format(os.path.dirname(__file__)))

def overrides_message(message):
  def decorator(function):
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
      try:
        return function(*args, **kwargs)
      except AssertionError as exception:
        kwargs['message'] = "{}{}".format(exception.args[0][0].lower(), exception.args[0][1:])
        formatted_message = message(*args, **kwargs) if hasattr(message, '__call__') else message.format(*args, **kwargs)
        raise AssertionError(formatted_message.encode('utf-8'))
    return wrapper
  return decorator

def check_appfile_wrapped(app):
  return check_appfile(app)

@tuxapp.memoizes()
@tuxapp.logs("Checking {}")
def check_url_status(url):
  import ssl
  try:
    from http.client import BadStatusLine
    from urllib.request import Request, URLError, urlopen
  except ImportError:
    from httplib import BadStatusLine
    from urllib2 import Request, URLError, urlopen
  try:
    return urlopen(Request(url, headers={'User-Agent': "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"})).getcode() == 200
  except (BadStatusLine, URLError, ssl.CertificateError):
    return False

@tuxapp.silences
def check_appfiles(apps):
  import contextlib
  import multiprocessing
  with contextlib.closing(multiprocessing.Pool(10)) as pool:
    return all(pool.imap_unordered(check_appfile_wrapped, apps))

@tuxapp.asserts("Malformed pattern")
def check_regex(pattern):
  try:
    return bool(re.compile(pattern))
  except re.error:
    return False

check_app = lambda app: \
  tuxapp.asserts("Invalid characters")(lambda: bool(re.match("^[a-z0-9-]*$", app)))() and \
  tuxapp.asserts("Edge dash")(lambda: not app.startswith('-') and not app.endswith('-'))() and \
  tuxapp.asserts("Continuous dashes")(lambda: not re.search(r"-{2}", app))()

check_appfile = lambda app: \
  overrides_message("{}: {message}")(check_app)(app) and \
  overrides_message("{}: {message}")(check_appfile_keys)(app) and \
  all(overrides_message(u"{}.{}: {{message}}{}".format(
    app,
    key,
    u" ({})".format(value.replace('{', "{{").replace('}', "}}")) if value else '',
  ))(check_appfile_item)(app, key, value) for key, value in parse_appfile(app))

check_appfile_exists = tuxapp.asserts("{}: unknown app")(
  lambda app: os.path.isfile(tuxapp.get_appfile_path(app)) and app
)

check_appfile_item = tuxapp.asserts("Unknown key")(
  lambda app, key, value: \
    check_category(value) \
      if key == 'category' else \
    check_description(app, value) \
      if key == 'description' else \
    all(check_download_url(app, url, re.sub(r"^download-(.+)-url", r'\1', key)) for url in value.split()) \
      if key.startswith('download-') and key.endswith('-url') else \
    True \
      if key == 'executable' else \
    check_firejail(value) \
      if key == 'firejail' else \
    check_free_license(value) \
      if key == 'free-license' else \
    check_homepage_url(value) \
      if key == 'homepage-url' else \
    check_icon_url(value) \
      if key == 'icon-url' else \
    check_group(value) \
      if key == 'group' else \
    check_name(app, value) \
      if key == 'name' else \
    check_note(value) \
      if key == 'note' else \
    True \
      if key == 'packages' else \
    check_title(app, value) \
      if key == 'title' else \
    check_version_regex(app, value) \
      if key == 'version-regex' else \
    check_version_url(value) \
      if key == 'version-url' else \
    None
)

check_appfile_keys = lambda app: \
  tuxapp.asserts("Extra lines")(lambda: all('=' in line for line in read_appfile(app).splitlines()))() and \
  tuxapp.asserts("No trailing newline")(lambda: read_appfile(app).endswith('\n'))() and \
  tuxapp.asserts("Not sorted")(lambda: parse_appfile_keys(app) == tuple(sorted(parse_appfile_keys(app))))() and \
  tuxapp.asserts("Extraneous keys")(lambda: not set(parse_appfile_keys(app)) - set(get_appfile_keys()))() and \
  tuxapp.asserts("Missing keys")(lambda: not set(get_appfile_keys()) - set(parse_appfile_keys(app)))() and \
  tuxapp.asserts("Doubled keys")(lambda: parse_appfile_keys(app) == get_appfile_keys())()

check_capitalized = tuxapp.asserts("Not capitalized")(
  lambda string: string[0] == string[0].upper()
)

check_category = lambda category: \
  check_value(category) and \
  tuxapp.asserts("Unknown category")(lambda: category in get_categories())()

check_description = lambda app, description: \
  not description or \
  check_value(description) and \
  check_capitalized(description) and \
  check_terminal_punctuation(description) and \
  check_homepage_contains(app, description)

check_download_url = lambda app, url, architecture: \
  architecture != 'x86-64' and not url or \
  tuxapp.asserts("Contains the version number")(lambda: tuxapp.fetch_app_version(app) not in url)() and \
  check_url(tuxapp.filter_app_download_url(app, url))

check_firejail = lambda options: \
  not options or \
  check_value(options) and \
  tuxapp.asserts("Failed to parse")(lambda: bool(tuxapp.unasserts(tuxapp.split_command)(options)))()

check_free_license = lambda value: \
  not value or \
  check_value(value) and \
  tuxapp.asserts("Value is not 'yes'")(lambda: value == 'yes')()

check_group = lambda group: \
  check_value(group) and \
  tuxapp.asserts("Unknown group")(lambda: group in get_groups())()

check_homepage_contains = tuxapp.asserts("Not found on the homepage")(
  lambda app, string, is_case_sensitive=False: \
    bool(re.search(
      r"\b{}\b".format(re.escape(re.sub(r"\s+", ' ', re.sub(r"\W+", ' ', string)))),
      fetch_url_text(tuxapp.query_appfile(app, 'homepage-url')),
      0 if is_case_sensitive else re.I | re.U,
    ))
)

check_homepage_url = lambda url: check_url(url)

check_icon_url = lambda url: check_url(url)

check_name = lambda app, name: \
  check_value(name) and \
  (name.startswith('~') or check_homepage_contains(app, name, True))

check_note = lambda note: \
  not note or \
  check_value(note) and \
  check_capitalized(note) and \
  check_terminal_punctuation(note)

check_terminal_punctuation = tuxapp.asserts(lambda string, is_inverted=False, *args, **kwargs: "Terminal punctuation" if is_inverted else "No terminal punctuation")(
  lambda string, is_inverted=False: (string[-1] in ('.', '!', '?')) ^ is_inverted
)

check_title = lambda app, title: \
  not title or \
  check_value(title) and \
  check_capitalized(title) and \
  check_terminal_punctuation(title, True) and \
  check_homepage_contains(app, title)

check_url = lambda url: \
  check_value(url) and \
  tuxapp.asserts("Invalid URL")(lambda: urlparse(url).scheme in ('http', 'https') and bool(urlparse(url).netloc) and bool(urlparse(url).path))() and \
  tuxapp.asserts("URL is accessible by HTTPS")(lambda: url.startswith("https://") or not check_url_status(url.replace("http://", "https://", 1)))() and \
  tuxapp.asserts("Inaccessible URL")(check_url_status)(url)

check_value = lambda string, is_whitespace_allowed=False: \
  tuxapp.asserts("Is required")(lambda: bool(string))() and \
  tuxapp.asserts("Tab character")(lambda: '\t' not in string)() and \
  tuxapp.asserts("Edge whitespace")(lambda: is_whitespace_allowed or not re.search(r"^\s", string) and not re.search(r"\s$", string))() and \
  tuxapp.asserts("Continuous whitespace")(lambda: is_whitespace_allowed or not re.search(r"\s{2}", string))()

check_version_regex = lambda app, pattern: \
  check_value(pattern, True) and \
  check_regex(pattern) and \
  bool(tuxapp.fetch_app_version(app, pattern))

check_version_url = lambda url: not url or check_url(url)

fetch_url_text = tuxapp.memoizes()(
  lambda url: re.sub(r"\s+", ' ', re.sub(r"\W+", ' ', re.sub(r"&[\w#]+;", ' ', re.sub(r"<(?!meta)[^>]+>", ' ', tuxapp.fetch_url(url)))))
)

get_appfile_keys = lambda: \
  (
    'category',
    'description',
    'download-x86-64-url',
    'download-x86-url',
    'executable',
    'firejail',
    'free-license',
    'group',
    'homepage-url',
    'icon-url',
    'name',
    'note',
    'packages',
    'title',
    'version-regex',
    'version-url',
  )

get_appfiles = lambda: tuple(sorted(tuxapp.extract_app(path) for path in glob.glob(tuxapp.get_appfile_path('*'))))

get_categories = lambda: \
  (
    'audio',
    'development',
    'education',
    'game',
    'graphics',
    'network',
    'office',
    'science',
    'settings',
    'system',
    'utility',
    'video',
  )

get_groups = lambda: \
  (
    'audio-streaming',
    'code-editors',
    'content-management',
    'e-book-readers',
    'email-clients',
    'instant-messengers',
    'note-taking',
    'office-suits',
    'role-playing',
    'version-control',
    'video-streaming',
    'web-browsers',
    'web-development',
  )

main = tuxapp.handles_exceptions(
  lambda arguments=tuple(sys.argv[1:]): check_appfiles(tuple(check_appfile_exists(tuxapp.extract_app(argument)) for argument in arguments) or get_appfiles())
)

parse_appfile = lambda app: tuple(line.split('=', 1) for line in read_appfile(app).splitlines())

parse_appfile_keys = lambda app: tuple(key for key, _ in parse_appfile(app))

read_appfile = lambda app: tuxapp.read_file(tuxapp.get_appfile_path(app))

if __name__ == '__main__':
  main()
